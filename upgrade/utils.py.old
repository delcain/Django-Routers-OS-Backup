#!/usr/bin/env python3
"""
Script para verifica√ß√£o e atualiza√ß√£o autom√°tica de roteadores MikroTik
Autor: Script automatizado
Data: 2025
"""

import librouteros
import time
import logging
import sys
from datetime import datetime
import json
import os

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('mikrotik_update.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

class MikroTikUpdater:
    def __init__(self, host, username, password, port=8728):
        self.host = host
        self.username = username
        self.password = password
        self.port = port
        self.api = None
        self.logger = logging.getLogger(__name__)

        
    def connect(self):
        """Conecta ao roteador MikroTik"""
        try:
            self.api = librouteros.connect(
                host=self.host,
                username=self.username,
                password=self.password,
                port=self.port,
                timeout=10
            )
            self.logger.info(f"Conectado ao MikroTik {self.host}")
            return True
        except Exception as e:
            self.logger.error(f"Erro ao conectar: {e}")
            return False
    
    def reboot(self):
        reboot = self.api.path('/system')
        reboot('reboot')

    def disconnect(self):
        """Desconecta do roteador"""
        if self.api:
            self.api.close()
            self.logger.info("Desconectado do MikroTik")
    
    def get_current_version(self):
        """Obt√©m a vers√£o atual do RouterOS"""
        try:
            resource = self.api.path('/system/resource')
            info = list(resource.select())[0]
            version = info.get('version', 'Desconhecida')
            self.logger.info(f"Vers√£o atual: {version}")
            return version
        except Exception as e:
            self.logger.error(f"Erro ao obter vers√£o atual: {e}")
            return None
    
    def check_for_updates(self):
        """Verifica se h√° atualiza√ß√µes dispon√≠veis"""
        try:
            # Atualiza a lista de pacotes dispon√≠veis
            package = self.api.path('/system/package/update')
            package('check-for-updates')
            
            # Aguarda a verifica√ß√£o completar
            time.sleep(10)
            
            # Obt√©m informa√ß√µes sobre atualiza√ß√µes
            updates = list(package.select())
            if updates:
                update_info = updates[0]
                latest_version = update_info.get('latest-version', 'N/A')
                installed_version = update_info.get('installed-version', 'N/A')
                
                self.logger.info(f"Vers√£o instalada: {installed_version}")
                self.logger.info(f"Vers√£o mais recente: {latest_version}")
                
                # Verifica se h√° atualiza√ß√£o dispon√≠vel
                if latest_version != 'N/A' and latest_version != installed_version:
                    self.logger.info("Atualiza√ß√£o dispon√≠vel!")
                    return True, latest_version, installed_version
                else:
                    self.logger.info("Sistema j√° est√° atualizado")
                    return False, latest_version, installed_version
            else:
                self.logger.warning("N√£o foi poss√≠vel verificar atualiza√ß√µes")
                return False, None, None
                
        except Exception as e:
            self.logger.error(f"Erro ao verificar atualiza√ß√µes: {e}")
            return False, None, None
    
    def download_update(self):
        """Faz download da atualiza√ß√£o"""
        try:
            self.logger.info("Iniciando download da atualiza√ß√£o...")
            package = self.api.path('/system/package/update')
            package('download')

            # Monitora o progresso do download
            while True:
                time.sleep(3)
                status_list = list(package.select())
                
                if status_list:
                    status = status_list[0]
                    
                    if 'status' in status:
                        current_status = status['status']
                        self.logger.info(f"Status do download: {current_status}")
                        
                        if current_status == 'Downloaded, please reboot router to upgrade it':
                            self.logger.info("Download conclu√≠do com sucesso!")
                            return True
                        
                        elif 'failed' in current_status.lower() or 'error' in current_status.lower():
                            self.logger.error(f"Falha no download: {current_status}")
                            return False
                    else:
                        # Verifica se h√° pacotes baixados
                        if 'Downloaded, please reboot router to upgrade it' in str(status).lower():
                            self.logger.info("Download aparentemente conclu√≠do")
                            return True
                else:
                    self.logger.warning("N√£o foi poss√≠vel obter status do download")
                    break
            return True
            
        except Exception as e:
            self.logger.error(f"Erro durante o download: {e}")
            return False
    
    def install_update(self):
        """Instala a atualiza√ß√£o baixada"""
        try:
            self.logger.info("Iniciando instala√ß√£o da atualiza√ß√£o...")
            self.logger.warning("ATEN√á√ÉO: O roteador ser√° reinicializado!")
            
            package = self.api.path('/system/package/update')
            package('install')
            
            self.logger.info("Comando de instala√ß√£o enviado. Roteador reiniciando...")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro durante a instala√ß√£o: {e}")
            return False
    
    def wait_for_reboot(self, timeout=300):
        """Aguarda o roteador reiniciar ap√≥s a atualiza√ß√£o"""
        self.logger.info("Aguardando reinicializa√ß√£o do roteador...")
        
        # Desconecta da sess√£o atual
        self.disconnect()
        
        # Aguarda um tempo antes de tentar reconectar
        time.sleep(60)
        
        start_time = time.time()
        while (time.time() - start_time) < timeout:
            try:
                if self.connect():
                    self.logger.info("Roteador voltou online ap√≥s atualiza√ß√£o!")
                    return True
            except:
                pass
            
            self.logger.info("Aguardando roteador ficar online...")
            time.sleep(30)
        
        self.logger.error("Timeout aguardando roteador voltar online")
        return False
    
    def get_system_identity(self):
        """Obt√©m a identidade do sistema"""
        try:
            identity = self.api.path('/system/identity')
            info = list(identity.select())[0]
            return info.get('name', 'MikroTik')
        except:
            return 'MikroTik'
    
    def create_backup(self):
        """Cria um backup antes da atualiza√ß√£o"""
        try:
            self.logger.info("Criando backup do sistema...")
            backup_name = f"backup_pre_update_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            backup = self.api.path('/system/backup')
            backup('save', {'name': backup_name})
            
            time.sleep(5)  # Aguarda o backup completar
            self.logger.info(f"Backup criado: {backup_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao criar backup: {e}")
            return False
    
    def perform_update(self, create_backup=True):
        """Executa o processo completo de atualiza√ß√£o"""
        self.logger.info("=== Iniciando processo de atualiza√ß√£o autom√°tica ===")
        
        if not self.connect():
            return False
        
        try:
            # Obt√©m informa√ß√µes do sistema
            identity = self.get_system_identity()
            current_version = self.get_current_version()
            self.logger.info(f"Roteador: {identity} - Vers√£o: {current_version}")
            
            # Verifica se h√° atualiza√ß√µes
            has_update, latest, installed = self.check_for_updates()
            
            if not has_update:
                self.logger.info("Nenhuma atualiza√ß√£o necess√°ria")
                return True
            
            self.logger.info(f"Atualiza√ß√£o dispon√≠vel: {installed} -> {latest}")
            
            # Cria backup se solicitado
            if create_backup:
                if not self.create_backup():
                    self.logger.warning("Falha ao criar backup, continuando mesmo assim...")
            
            # Faz download da atualiza√ß√£o
            if not self.download_update():
                self.logger.error("Falha no download da atualiza√ß√£o")
                return False
            
            # Instala a atualiza√ß√£o
            if not self.install_update():
                self.logger.error("Falha na instala√ß√£o da atualiza√ß√£o")
                return False
            
            # Aguarda reinicializa√ß√£o
            if not self.wait_for_reboot():
                self.logger.error("Roteador n√£o voltou online ap√≥s atualiza√ß√£o")
                return False
            
            # Verifica a nova vers√£o
            new_version = self.get_current_version()
            self.logger.info(f"Atualiza√ß√£o conclu√≠da! Nova vers√£o: {new_version}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Erro durante processo de atualiza√ß√£o: {e}")
            return False
        finally:
            self.disconnect()

def load_config(config_file='mikrotik_config.json'):
    """Carrega configura√ß√£o do arquivo JSON"""
    default_config = {
        "routers": [
            {
                "name": "Router Principal",
                "host": "192.168.1.1",
                "username": "admin",
                "password": "password",
                "port": 8728
            }
        ],
        "settings": {
            "create_backup": True,
            "check_interval_hours": 24,
            "log_level": "INFO"
        }
    }
    
    if os.path.exists(config_file):
        try:
            with open(config_file, 'r') as f:
                return json.load(f)
        except Exception as e:
            logging.error(f"Erro ao carregar configura√ß√£o: {e}")
            return default_config
    else:
        # Cria arquivo de configura√ß√£o padr√£o
        with open(config_file, 'w') as f:
            json.dump(default_config, f, indent=2)
        logging.info(f"Arquivo de configura√ß√£o criado: {config_file}")
        return default_config

def main():
    """Fun√ß√£o principal"""
    config = load_config()
    
    for router_config in config['routers']:
        updater = MikroTikUpdater(
            host=router_config['host'],
            username=router_config['username'],
            password=router_config['password'],
            port=router_config.get('port', 8728)
        )
        
        logging.info(f"\n=== Processando {router_config['name']} ({router_config['host']}) ===")
        
        success = updater.perform_update(
            create_backup=config['settings'].get('create_backup', True)
        )
        
        if success:
            logging.info(f"‚úÖ {router_config['name']}: Processo conclu√≠do com sucesso")
        else:
            logging.error(f"‚ùå {router_config['name']}: Processo falhou")

if __name__ == "__main__":
    # Verificar se a biblioteca librouteros est√° instalada
    try:
        import librouteros
    except ImportError:
        print("‚ùå Biblioteca 'librouteros' n√£o encontrada!")
        print("üì¶ Instale com: pip install librouteros")
        sys.exit(1)
    
    main()