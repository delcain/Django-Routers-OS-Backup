#!/usr/bin/env python3
"""
Script para verificação e atualização automática de roteadores MikroTik
Autor: Script automatizado
Data: 2025
"""

import librouteros
import time
import logging
import sys
from datetime import datetime
import json
import os

# Configuração de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('mikrotik_update.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

class MikroTikUpdater:
    def __init__(self, host, username, password, port=8728):
        self.host = host
        self.username = username
        self.password = password
        self.port = port
        self.api = None
        self.logger = logging.getLogger(__name__)

        
    def connect(self):
        """Conecta ao roteador MikroTik"""
        try:
            self.api = librouteros.connect(
                host=self.host,
                username=self.username,
                password=self.password,
                port=self.port,
                timeout=10
            )
            self.logger.info(f"Conectado ao MikroTik {self.host}")
            return True
        except Exception as e:
            self.logger.error(f"Erro ao conectar: {e}")
            return False
    
    def reboot(self):
        reboot = self.api.path('/system')
        reboot('reboot')

    def disconnect(self):
        """Desconecta do roteador"""
        if self.api:
            self.api.close()
            self.logger.info("Desconectado do MikroTik")
    
    def get_current_version(self):
        """Obtém a versão atual do RouterOS"""
        try:
            resource = self.api.path('/system/resource')
            info = list(resource.select())[0]
            version = info.get('version', 'Desconhecida')
            self.logger.info(f"Versão atual: {version}")
            return version
        except Exception as e:
            self.logger.error(f"Erro ao obter versão atual: {e}")
            return None
    
    def check_for_updates(self):
        """Verifica se há atualizações disponíveis"""
        try:
            # Atualiza a lista de pacotes disponíveis
            package = self.api.path('/system/package/update')
            package('check-for-updates')
            
            # Aguarda a verificação completar
            time.sleep(10)
            
            # Obtém informações sobre atualizações
            updates = list(package.select())
            if updates:
                update_info = updates[0]
                latest_version = update_info.get('latest-version', 'N/A')
                installed_version = update_info.get('installed-version', 'N/A')
                
                self.logger.info(f"Versão instalada: {installed_version}")
                self.logger.info(f"Versão mais recente: {latest_version}")
                
                # Verifica se há atualização disponível
                if latest_version != 'N/A' and latest_version != installed_version:
                    self.logger.info("Atualização disponível!")
                    return True, latest_version, installed_version
                else:
                    self.logger.info("Sistema já está atualizado")
                    return False, latest_version, installed_version
            else:
                self.logger.warning("Não foi possível verificar atualizações")
                return False, None, None
                
        except Exception as e:
            self.logger.error(f"Erro ao verificar atualizações: {e}")
            return False, None, None
    
    def download_update(self):
        """Faz download da atualização"""
        try:
            self.logger.info("Iniciando download da atualização...")
            package = self.api.path('/system/package/update')
            package('download')

            # Monitora o progresso do download
            while True:
                time.sleep(3)
                status_list = list(package.select())
                
                if status_list:
                    status = status_list[0]
                    
                    if 'status' in status:
                        current_status = status['status']
                        self.logger.info(f"Status do download: {current_status}")
                        
                        if current_status == 'Downloaded, please reboot router to upgrade it':
                            self.logger.info("Download concluído com sucesso!")
                            return True
                        
                        elif 'failed' in current_status.lower() or 'error' in current_status.lower():
                            self.logger.error(f"Falha no download: {current_status}")
                            return False
                    else:
                        # Verifica se há pacotes baixados
                        if 'Downloaded, please reboot router to upgrade it' in str(status).lower():
                            self.logger.info("Download aparentemente concluído")
                            return True
                else:
                    self.logger.warning("Não foi possível obter status do download")
                    break
            return True
            
        except Exception as e:
            self.logger.error(f"Erro durante o download: {e}")
            return False
    
    def install_update(self):
        """Instala a atualização baixada"""
        try:
            self.logger.info("Iniciando instalação da atualização...")
            self.logger.warning("ATENÇÃO: O roteador será reinicializado!")
            
            package = self.api.path('/system/package/update')
            package('install')
            
            self.logger.info("Comando de instalação enviado. Roteador reiniciando...")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro durante a instalação: {e}")
            return False
    
    def wait_for_reboot(self, timeout=300):
        """Aguarda o roteador reiniciar após a atualização"""
        self.logger.info("Aguardando reinicialização do roteador...")
        
        # Desconecta da sessão atual
        self.disconnect()
        
        # Aguarda um tempo antes de tentar reconectar
        time.sleep(60)
        
        start_time = time.time()
        while (time.time() - start_time) < timeout:
            try:
                if self.connect():
                    self.logger.info("Roteador voltou online após atualização!")
                    return True
            except:
                pass
            
            self.logger.info("Aguardando roteador ficar online...")
            time.sleep(30)
        
        self.logger.error("Timeout aguardando roteador voltar online")
        return False
    
    def get_system_identity(self):
        """Obtém a identidade do sistema"""
        try:
            identity = self.api.path('/system/identity')
            info = list(identity.select())[0]
            return info.get('name', 'MikroTik')
        except:
            return 'MikroTik'
    
    def create_backup(self):
        """Cria um backup antes da atualização"""
        try:
            self.logger.info("Criando backup do sistema...")
            backup_name = f"backup_pre_update_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            backup = self.api.path('/system/backup')
            backup('save', {'name': backup_name})
            
            time.sleep(5)  # Aguarda o backup completar
            self.logger.info(f"Backup criado: {backup_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao criar backup: {e}")
            return False
    
    def perform_update(self, create_backup=True):
        """Executa o processo completo de atualização"""
        self.logger.info("=== Iniciando processo de atualização automática ===")
        
        if not self.connect():
            return False
        
        try:
            # Obtém informações do sistema
            identity = self.get_system_identity()
            current_version = self.get_current_version()
            self.logger.info(f"Roteador: {identity} - Versão: {current_version}")
            
            # Verifica se há atualizações
            has_update, latest, installed = self.check_for_updates()
            
            if not has_update:
                self.logger.info("Nenhuma atualização necessária")
                return True
            
            self.logger.info(f"Atualização disponível: {installed} -> {latest}")
            
            # Cria backup se solicitado
            if create_backup:
                if not self.create_backup():
                    self.logger.warning("Falha ao criar backup, continuando mesmo assim...")
            
            # Faz download da atualização
            if not self.download_update():
                self.logger.error("Falha no download da atualização")
                return False
            
            # Instala a atualização
            if not self.install_update():
                self.logger.error("Falha na instalação da atualização")
                return False
            
            # Aguarda reinicialização
            if not self.wait_for_reboot():
                self.logger.error("Roteador não voltou online após atualização")
                return False
            
            # Verifica a nova versão
            new_version = self.get_current_version()
            self.logger.info(f"Atualização concluída! Nova versão: {new_version}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Erro durante processo de atualização: {e}")
            return False
        finally:
            self.disconnect()

def load_config(config_file='mikrotik_config.json'):
    """Carrega configuração do arquivo JSON"""
    default_config = {
        "routers": [
            {
                "name": "Router Principal",
                "host": "192.168.1.1",
                "username": "admin",
                "password": "password",
                "port": 8728
            }
        ],
        "settings": {
            "create_backup": True,
            "check_interval_hours": 24,
            "log_level": "INFO"
        }
    }
    
    if os.path.exists(config_file):
        try:
            with open(config_file, 'r') as f:
                return json.load(f)
        except Exception as e:
            logging.error(f"Erro ao carregar configuração: {e}")
            return default_config
    else:
        # Cria arquivo de configuração padrão
        with open(config_file, 'w') as f:
            json.dump(default_config, f, indent=2)
        logging.info(f"Arquivo de configuração criado: {config_file}")
        return default_config

def main():
    """Função principal"""
    config = load_config()
    
    for router_config in config['routers']:
        updater = MikroTikUpdater(
            host=router_config['host'],
            username=router_config['username'],
            password=router_config['password'],
            port=router_config.get('port', 8728)
        )
        
        logging.info(f"\n=== Processando {router_config['name']} ({router_config['host']}) ===")
        
        success = updater.perform_update(
            create_backup=config['settings'].get('create_backup', True)
        )
        
        if success:
            logging.info(f"✅ {router_config['name']}: Processo concluído com sucesso")
        else:
            logging.error(f"❌ {router_config['name']}: Processo falhou")

if __name__ == "__main__":
    # Verificar se a biblioteca librouteros está instalada
    try:
        import librouteros
    except ImportError:
        print("❌ Biblioteca 'librouteros' não encontrada!")
        print("📦 Instale com: pip install librouteros")
        sys.exit(1)
    
    main()